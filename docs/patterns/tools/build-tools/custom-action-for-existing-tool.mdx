---
title: "Build an Action for existing Tool"
sidebarTitle: "Build an Action for existing Tool"
icon: "toolbox"
description: "Extend the functionality of existing tools by creating a custom action which utilises the existing authentication. (e.g., fetch emails from Gmail)"
---

<Tip>
Custom Actions are flexible building blocks that let you create any functionality you need - from simple calculations to complex integrations. They work seamlessly with Composio's authentication system for existing tools, or can run independently for custom logic.
</Tip>

## Creating a Custom Action for an Existing Tool

<Steps>
<Step title="Import necessary modules">

<CodeGroup>
```python Python
from composio import ComposioToolSet, App, action

toolset = ComposioToolSet()
```
```javascript Javascript
import { OpenAIToolSet } from "composio-core"
import { z } from "zod"

const toolset = new OpenAIToolSet({})
```
</CodeGroup>
</Step>

<Step title="Creating a custom action">
Below is an example of creating `my_custom_action` a custom action for the `gmail` tool. The action is designed to fetch emails from a Gmail account for the last 24 hours using the existing authentication provided by Composio.
<Note>

As `gmail` toolname is already registered in Composio, `auth` dictionary will be automatically provided!
</Note>
<CodeGroup>
```python Python
@action(toolname="gmail", requires=["example-pypi-package"])  # supports any package
def my_custom_action(auth: dict, account_id: str) -> str: # Uses existing gmail auth
    """
    Fetch emails from Gmail account for last 24 hours

    :param account_id: Account ID, pass 'me' for default account
    :param auth: Authentication dictionary provided by Composio for Gmail
    :return info: Gmail emails information
    """

    # fetch authentication headers
    headers = auth["headers"]
    query_params = auth["query_params"]
    base_url = auth["base_url"]

    yesterday_dateTime = int(
        (datetime.datetime.now() + datetime.timedelta(days=-1)).timestamp()
    )

    if account_id and account_id != "":
        custom_endpoint_url = f"/gmail/v1/users/{account_id}/messages?q=after:{yesterday_dateTime}"
    else:
        custom_endpoint_url = f"/gmail/v1/users/me/messages?q=after:{yesterday_dateTime}"

    # add query params to the url
    for key, value in query_params.items():
        custom_endpoint_url += f"&{key}={value}"
    
    url = f"{base_url}{custom_endpoint_url}"

    response = requests.get(url, headers=headers)

    if response.status_code == 200:
        print("Successfully fetched emails:", response.json())
    else:
        print("Error fetching emails:", response.status_code, response.json())
    return str(response)
```

```javascript Javascript
await toolset.createAction({
    actionName: "myCustomAction",
    toolName: "gmail",
    description: "Fetch emails from Gmail account for last 24 hours",
    inputParams: z.object({
        accountId: z.string().describe("Gmail account ID. Defaults to the primary account, which is 'me'."),
    }),
    callback: async (inputParams, authCredentials) => {
        const headers = authCredentials.headers;
        const query_params = authCredentials.query_params;
        const base_url = authCredentials.baseUrl;
        
        const oneDayAgo = Math.floor(Date.now() / 1000) - 86400;
        const customEndpointUrl = `/gmail/v1/users/${inputParams.accountId}/messages?q=after:${oneDayAgo}`;
        const url = `${base_url}${customEndpointUrl}`;
        const response = await fetch(url, { headers });

        if (response.ok) {
            const data = await response.json();
            console.log("Successfully fetched emails:", data);
            return data;
        } else {
            const errorData = await response.json();
            console.error("Error fetching emails:", response.status, errorData);
            throw new Error(`Error fetching emails: ${response.status}`);
        }
    }
});
```
</CodeGroup>

</Step>
<Step title="Executing the Custom Action">
Executing the custom action without Agents (it can be used with agents too)
<CodeGroup>
```python Python
toolset.execute_action(
    action=my_custom_action,
    params={
        'account_id':'me' 
    },
)
```

```javascript JavaScript
console.log(
    await toolset.executeAction(
        "myCustomAction",
        { accountId: "me" }
    )
)
```
</CodeGroup>


Output from executing Custom Action
<CodeGroup>
```shell Output
[INFO] Logging is set to INFO, use `logging_level` argument or `COMPOSIO_LOGGING_LEVEL` change this
[INFO] Executing `GMAIL_MY_CUSTOM_ACTION` with params={'query': 'test_query'} and metadata=None connected_account_id=None
[INFO] Got response={'data': {'info': {'headers': {'Authorization': 'Bearer KEY', 'x-request-id': '2c65e8b'}, 'base_url': 'https://api.github.com', 'query_params': {}}}, 'error': None, 'successful'...
{'data': {'info': {'headers': {'Authorization': 'Bearer KEY', 'x-request-id': '2c65e8b'}, 'base_url': 'https://api.github.com', 'query_params': {}}}, 'error': None, 'successful': True}
```
</CodeGroup>
</Step>
</Steps>

### Why Use Custom Actions?

Custom Actions provide several advantages:

- **Data privacy:** Execution happens on the user’s machine, ensuring sensitive data doesn’t leave the local environment.
- **Flexibility:** Users can create and customize as many tools and actions as needed.
- **Compatibility:** Custom actions can be integrated seamlessly across various Composio-supported platforms.
